<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>YUKIMEMI</title>
    <link>http://yukimemi.github.io/</link>
    <description>Recent content on YUKIMEMI</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sun, 01 Oct 2017 18:21:37 +0900</lastBuildDate>
    
	<atom:link href="http://yukimemi.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Fix conf with single user mode on mac</title>
      <link>http://yukimemi.github.io/post/2017-10-01_fix-conf-with-single-user-mode-on-mac/</link>
      <pubDate>Sun, 01 Oct 2017 18:21:37 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2017-10-01_fix-conf-with-single-user-mode-on-mac/</guid>
      <description>mac でシングルユーザーモードの起動と、設定ファイルの修正方法。
nas の自動マウントを行おうとして、 automount の設定を変更していたら、再起動後、 mac が起動しなくなった。
その修正方法。
Mac をシングルユーザモードまたは Verbose モードで起動する
ここを見ればわかるが、mac起動時に、 Command + S を押しっぱなしでシングルユーザーモードに入れる。
んで、あとは、 vi で設定をもとに戻して終了・・・っと思いきや、設定を書き込み出来なかった。
デフォルトだと、 / が読み込み専用でマウントされている。 書き込み可能で再マウントする。 (High Sierra だったので、APFS)
# mount_apfs -uw /  これで書き込みできる。 設定は、 man で確認できる。
# man 8 mount  修正後、再起動して完了。
# reboot  参考 Mac をシングルユーザモードまたは Verbose モードで起動する</description>
    </item>
    
    <item>
      <title>Use minpac.vim</title>
      <link>http://yukimemi.github.io/post/2017-09-17_use-minpac.vim/</link>
      <pubDate>Sun, 17 Sep 2017 23:30:20 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2017-09-17_use-minpac.vim/</guid>
      <description>vim や neovim で標準で用意されている package 機能。まだ一度も触ったことがなかったので使ってみた。
使ってみるに当たって、 k-takata/minpac が 便利そうなので、利用してみた。
&amp;quot; Plugin: &amp;quot; Use minpac. {{{1 set packpath^=&#39;~/.cache/nvim/&#39; let s:minpac_dir = &#39;~/.cache/nvim/pack/minpac/opt/minpac&#39; if has(&#39;vim_starting&#39;) if !isdirectory(s:minpac_dir) echo &amp;quot;Install minpac ...&amp;quot; execute &#39;!git clone --depth 1 https://github.com/k-takata/minpac &#39; . s:minpac_dir endif endif &amp;quot; pack list. {{{1 &amp;quot; start plugins. {{{2 let s:start_plugs = [ \ [&#39;Yggdroot/indentLine&#39;, {}], \ [&#39;itchyny/lightline.vim&#39;, {}], \ ] &amp;quot; opt plugins. {{{2 let s:opt_plugs = [ \ [&#39;fatih/vim-go&#39;, {&#39;type&#39;: &#39;opt&#39;}], \ [&#39;zchee/deoplete-go&#39;, {&#39;type&#39;: &#39;opt&#39;, &#39;do&#39;: &#39;silent!</description>
    </item>
    
    <item>
      <title>Setting of the vim-plug</title>
      <link>http://yukimemi.github.io/post/2017-06-08_vim-plug/</link>
      <pubDate>Thu, 08 Jun 2017 07:43:37 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2017-06-08_vim-plug/</guid>
      <description>ずっと dein.vim を使っていたのだけれど、ちょっと他のも試しに使ってみるかと思って、こっちも人気のある、 vim-plug を試しに使ってみた。
設定は公式のREADMEとかを参考にして、こんな感じになった。 (全部じゃないけど、抜粋して)
&amp;quot; Plugin: {{{1 &amp;quot; Use vim-plug. let s:cache_home = expand(&#39;~/.cache/nvim&#39;) let s:plug_dir = s:cache_home . &#39;/plugs&#39; let s:vim_plug_dir = s:cache_home . &#39;/vim-plug&#39; if has(&#39;vim_starting&#39;) if !isdirectory(s:vim_plug_dir) echo &amp;quot;Install vim-plug ...&amp;quot; execute &#39;!git clone --depth 1 https://github.com/junegunn/vim-plug.git &#39; . s:vim_plug_dir . &#39;/autoload&#39; endif execute &#39;set runtimepath^=&#39; . fnamemodify(s:vim_plug_dir, &#39;:p&#39;) endif &amp;quot; Helper function. function! Cond(cond, ...) let opts = get(a:000, 0, {}) return a:cond ?</description>
    </item>
    
    <item>
      <title>Use denite instead of unite</title>
      <link>http://yukimemi.github.io/post/2017-05-24_use-denite/</link>
      <pubDate>Wed, 24 May 2017 18:15:16 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2017-05-24_use-denite/</guid>
      <description>やろうやろうと思っていた、 Denite をついに使ってみた。
dein を使って toml で設定。
# ==================== Denite ==================== {{{1 [[plugins]] repo = &#39;Shougo/denite.nvim&#39; on_cmd = &#39;Denite&#39; if = &amp;quot;has(&#39;python3&#39;)&amp;quot; hook_add = &#39;&#39;&#39; &amp;quot; Use plefix s nnoremap suc :&amp;lt;C-u&amp;gt;Denite colorscheme -auto-preview&amp;lt;CR&amp;gt; nnoremap sub :&amp;lt;C-u&amp;gt;Denite buffer&amp;lt;CR&amp;gt; nnoremap suf :&amp;lt;C-u&amp;gt;Denite file&amp;lt;CR&amp;gt; nnoremap suF :&amp;lt;C-u&amp;gt;Denite file_rec&amp;lt;CR&amp;gt; nnoremap suu :&amp;lt;C-u&amp;gt;Denite buffer file_old&amp;lt;CR&amp;gt; nnoremap suo :&amp;lt;C-u&amp;gt;Denite outline -no-quit -mode=normal&amp;lt;CR&amp;gt; nnoremap suh :&amp;lt;C-u&amp;gt;Denite help&amp;lt;CR&amp;gt; nnoremap sur :&amp;lt;C-u&amp;gt;Denite register&amp;lt;CR&amp;gt; nnoremap sug :&amp;lt;C-u&amp;gt;Denite grep -no-empty&amp;lt;CR&amp;gt; nnoremap su/ :&amp;lt;C-u&amp;gt;Denite line&amp;lt;CR&amp;gt; nnoremap suR :&amp;lt;C-u&amp;gt;Denite -resume&amp;lt;CR&amp;gt; noremap sul :&amp;lt;C-u&amp;gt;Denite command_history&amp;lt;CR&amp;gt; &#39;&#39;&#39; hook_post_source = &#39;&#39;&#39; &amp;quot; Default options.</description>
    </item>
    
    <item>
      <title>Git status recurse</title>
      <link>http://yukimemi.github.io/post/2017-03-19_git-status-recurse/</link>
      <pubDate>Sun, 19 Mar 2017 00:00:07 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2017-03-19_git-status-recurse/</guid>
      <description>git status を再帰的に全Gitディレクトリで実行して、変更のあるリポジトリを簡単に見つけたい。
と思ったので作りました。
yukimemi/gsr
go get でインストールできます。
(バイナリファイルもそのうち用意する)
$ go get github.com/yukimemi/gsr  使い方は簡単で
$ gsr [再帰的にチェックしたいディレクトリ]  とすると、 git status で変更のあるディレクトリだけ出力されます。 デフォルトでは、ディレクトリ名だけが出力されます。
$ gsr --status [再帰的にチェックしたいディレクトリ]  と、オプションをつけると、 git status --short の出力結果も出力されます。
ちなみに、 [再帰的にチェックしたいディレクトリ] を指定しなかった場合、 ghq root を対象にチェックします。
motemen/ghq を使っている人には便利です。
デフォルトの出力がディレクトリ名なのは、pecoとか使って移動したいからです。
例えば、 .zshrc に、こんな設定を書いてやると、
function __filter() { peco | while read line do echo &amp;quot;Exec: [$@ $line]&amp;quot; $@ $line done } alias gsrl=&#39;gsr | __filter cd&#39; alias ghl=&#39;gsr --all | __filter cd&#39;  gsrl で、 ghq で管理された変更のあるgitディレクトリに移動出来るようになり、 ghl で ghq で管理されたすべてのディレクトリに移動出来るようになります。</description>
    </item>
    
    <item>
      <title>Use highlight.js with CDN</title>
      <link>http://yukimemi.github.io/post/2016-12-10_use-highlight.js-with-cdn/</link>
      <pubDate>Sat, 10 Dec 2016 22:01:28 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2016-12-10_use-highlight.js-with-cdn/</guid>
      <description>highlight.js を、 CDN で使用する方法。
このブログを書くのに今までは google/code-prettify を使っていたんだけど、うまく hightlight されないのがあったりしたので、 highlight.js に乗り換えてみた。
使い方は非常に簡単。
ヘッダーに以下3行を追加するだけ。(スタイルは onedark を使用)
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/styles/atom-one-dark.min.css&amp;quot;&amp;gt; &amp;lt;script src=&amp;quot;//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt;hljs.initHighlightingOnLoad();&amp;lt;/script&amp;gt;  ただ、これでは基本的な言語のハイライトしか設定出来ない。 powershell とか、 golang とかも対応したい場合、個別に追加する必要がある。
highlight.js のサイトで個別に言語を指定してダウンロードすることもできるが、全部ポチポチ指定してダウンロードするのは面倒だったので、直接 CDN から使いたかった。
調べると、 isagalaev/highlight.js の README に書いてあった。 個別に使いたい言語を CDN から使うように指定すればいいみたい。
ということで、以下のようになりました。
&amp;lt;!-- hilight.js --&amp;gt; &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/styles/atom-one-dark.min.css&amp;quot;&amp;gt; &amp;lt;script src=&amp;quot;//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;quot;//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/languages/vim.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;quot;//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/languages/dos.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;quot;//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/languages/go.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;quot;//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/languages/powershell.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;quot;//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/languages/haskell.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt;hljs.initHighlightingOnLoad();&amp;lt;/script&amp;gt;  べんり。
参考 コードのハイライト表示用 JS ライブラリ highlight.js の使い方
軽量で多言語なコードハイライトhighlight.jsの使い方</description>
    </item>
    
    <item>
      <title>dein and vim singleton</title>
      <link>http://yukimemi.github.io/post/2016-12-09_dein-and-vim-singleton/</link>
      <pubDate>Fri, 09 Dec 2016 10:20:28 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2016-12-09_dein-and-vim-singleton/</guid>
      <description>vim-singleton という便利な vim plugin がある。
vim の clientserver 機能を使って、ファイルをすでに起動している vim で開くことができる。
これを dein.vim と一緒に使用する時の方法がわからなかったので、 twitter でつぶやいてみた。
@yukimemi hook_source を使ってください。hook_add はロード前に呼ばれるのでエラーとなります
&amp;mdash; 暗黒美夢王(deoplete dev) (@ShougoMatsu) 2016年12月5日 
そしたらなんとあの Shougo さんからお返事が！！
親切に教えてもらえました！
そこで教えてもらった通り、 hook_add から hook_source に変更。
こんな感じ。
 dein.toml  [[plugins]] repo = &#39;thinca/vim-singleton&#39; if = &amp;quot;!has(&#39;nvim&#39;)&amp;quot; hook_source = &#39;&#39;&#39; call singleton#enable() &#39;&#39;&#39;  それから、 lazy でないプラグインは、 hook_source は動かないため、 dein のドキュメントに書いてあるように dein#call_hook(&#39;source&#39;) を手動で呼ぶ必要がある。
 init.vim  set shellslash if has(&#39;nvim&#39;) let $VIM_PATH = expand(&#39;~/.</description>
    </item>
    
    <item>
      <title>Use fish instead of zsh</title>
      <link>http://yukimemi.github.io/post/2016-11-27_use-fish-instead-of-zsh/</link>
      <pubDate>Sun, 27 Nov 2016 00:49:25 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2016-11-27_use-fish-instead-of-zsh/</guid>
      <description>ちまたで(？)話題の fish を使ってみた。
長年使ってきた zsh のかわりにはならないだろうなーと思いながら・・・。
・・・が、いざ使ってみると非常に使いやすい！
zsh のかわりになるどころか置き換えてしまった。
(つまり、自分は結局そこまで zsh を使いこなしていなかったんだろう・・・。)
fish のチュートリアルは、以下にある。
fish tutorial
日本語でもqiitaとかにいっぱい解説記事があるので難しいことはないと思う。 唯一はまったのは、上記tutorialにある、 hybrid_bindings 。
vi っぽいキーバインドで、 insert モードの場合は emacs っぽくするって感じなんだろうけど、使用できなかった。 なんか issue 上がってたりしたので、そのうち修正されるのかもしれない。
とりあえずは、必要なキーバインドのみを自分で再定義してやることで要望は満たせた。
fish では、 fisherman というプラグインマネージャーが存在しており、これを使って各種プラグインを管理する。 日本語での解説も書いてあるので導入は簡単。
$ curl -Lo ~/.config/fish/functions/fisher.fish --create-dirs git.io/fisher  上記を実行するだけ。
自分が入れたパッケージはとりあえずこんだけ。
 simple : シンプルなテーマ omf/gi : gitignore を管理できるやつ。  2個だけ。 fish が単体で色々出来るやつだからこそかも。
fish は、設定を ~/.config/fish 配下で管理する。 こんな感じ。
$ tree fish fish ├── completions ├── conf.d ├── config.</description>
    </item>
    
    <item>
      <title>js beautify with vim</title>
      <link>http://yukimemi.github.io/post/2016-10-09_js-beautify-with-vim/</link>
      <pubDate>Sun, 09 Oct 2016 11:23:19 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2016-10-09_js-beautify-with-vim/</guid>
      <description>vimでjavascriptを書くときの設定。
 dein.toml  # ==================== Filetype (javascript) ===== {{{1 [[plugins]] repo = &#39;pangloss/vim-javascript&#39; on_ft = [&#39;javascript&#39;, &#39;javascript.jsx&#39;] [[plugins]] repo = &#39;maxmellon/vim-jsx-pretty&#39; on_ft = [&#39;javascript&#39;, &#39;javascript.jsx&#39;] [[plugins]] repo = &#39;othree/javascript-libraries-syntax.vim&#39; on_ft = [&#39;javascript&#39;, &#39;javascript.jsx&#39;] [[plugins]] repo = &#39;othree/es.next.syntax.vim&#39; on_ft = [&#39;javascript&#39;, &#39;javascript.jsx&#39;] # ==================== Utility =================== {{{1 [[plugins]] repo = &#39;Chiel92/vim-autoformat&#39; hook_add = &#39;&#39;&#39; let g:autoformat_autoindent = 0 let g:autoformat_retab = 0 let g:autoformat_remove_trailing_spaces = 0 au MyAutoCmd BufWrite *.</description>
    </item>
    
    <item>
      <title>Zsh autosuggestions</title>
      <link>http://yukimemi.github.io/post/2016-09-25_zsh-autosuggestions/</link>
      <pubDate>Sun, 25 Sep 2016 23:53:12 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2016-09-25_zsh-autosuggestions/</guid>
      <description>zsh-autosuggestions という便利な zsh のプラギンを見つけた。
zplug を使って簡単にインストール可能。
zplug &amp;quot;zsh-users/zsh-autosuggestions&amp;quot;  あとは、表示された補完を決定するキーの設定を追加。 ちなみにデフォルトだと、右矢印が割り当てられてる模様。
bindkey &#39;^ &#39; autosuggest-accept  で、 Ctrl + Space で、補完候補が確定する。
べんり。</description>
    </item>
    
    <item>
      <title>Use solarized colorscheme in true color</title>
      <link>http://yukimemi.github.io/post/2016-09-19_use-solarized-colorscheme-in-true-color/</link>
      <pubDate>Mon, 19 Sep 2016 11:15:50 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2016-09-19_use-solarized-colorscheme-in-true-color/</guid>
      <description>前回の記事(True color in iTerm2 Tmux Neovim | YUKIMEMI)で、 iterm と neovim でtrue colorを使う方法はわかったんだけど、なぜか、 solarized の colorscheme が有効にならなかった。
通常の solarized ではダメなようで、true color対応したやつを使えばいいみたい。
[[plugins]] repo = &#39;lifepillar/vim-solarized8&#39;  colorscheme solarized8_dark  これでできた。
参考 tmux on iTerm2 で斜体 &amp;amp; True Color を使う - Qiita</description>
    </item>
    
    <item>
      <title>True color in iTerm2 Tmux Neovim</title>
      <link>http://yukimemi.github.io/post/2016-09-19_true-color-in-iterm2-tmux-neovim/</link>
      <pubDate>Mon, 19 Sep 2016 00:30:00 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2016-09-19_true-color-in-iterm2-tmux-neovim/</guid>
      <description>今時 macbook のキレイな画面で256色なんて・・・
っということで、 True color が使えるそうなので設定してみた。
まず、 iTerm2 の設定。
は特になく、 homebrew cask でインストールすればそのまま true color が使えるらしい。
$ brew cask install iterm2  次に tmux の設定。 tmux はバージョン 2.2 以上ならOKっぽい。普通に homebrew でインストールしたら 2.2 だった。
$ brew install tmux  で、設定ファイル tmux.conf に以下を追加。
set -ga terminal-overrides &amp;quot;,xterm-256color:Tc&amp;quot;  もし、以下の設定が書いてあったらコメントアウト。
# set -g default-terminal xterm-256color  それから、 neovim の設定 ( init.vim )。
if has(&#39;nvim&#39;) set termguicolors endif  これでOK。 昔の設定は、 let $NVIM_TUI_ENABLE_TRUE_COLOR=1 とかだったらしいけど、2016/5/11から変わったっぽい。</description>
    </item>
    
    <item>
      <title>flowtype in vim</title>
      <link>http://yukimemi.github.io/post/2016-09-18_flowtype-in-vim/</link>
      <pubDate>Sun, 18 Sep 2016 13:03:18 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2016-09-18_flowtype-in-vim/</guid>
      <description>最近 flowtype という Altjs があるのを知った。
facebookが作っているらしく、 typescript と違って、既存のjavascriptをそのまま使うことも出来、型エラーがあってもコンパイル、実行が出来る。
導入は npm で簡単にインストール出来る。
$ npm i -g flow-bin  flowtype 自体の説明は 型なき世界のためのflowtype入門 - Qiita とか、公式の Flow | A static type checker for JavaScript とか見ればいいと思う。
んで、公式にも書いてあるように、vimやemacsのプラギンが提供されている。
flowtype/vim-flow: A vim plugin for Flow
neovim dein でのインストール手順。 toml を使っている前提。
[[plugins]] repo = &#39;flowtype/vim-flow&#39; on_ft = [&#39;javascript&#39;, &#39;javascript.jsx&#39;] build = &#39;npm install -g flow-bin&#39; hook_add = &#39;&#39;&#39; let g:flow#autoclose = 1 &#39;&#39;&#39; [[plugins]] repo = &#39;Shougo/deoplete.</description>
    </item>
    
    <item>
      <title>Type sound with Tickeys</title>
      <link>http://yukimemi.github.io/post/2016-09-03_type-sound-with-tickeys/</link>
      <pubDate>Sat, 03 Sep 2016 10:56:35 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2016-09-03_type-sound-with-tickeys/</guid>
      <description>最近、 Emacsで効果音(SE)を付けて作業効率を3倍にする方法 という記事を見つけた。
やっぱ音があった方がやる気が出るし、コードもすらすら書けるのではないか？ 僕は形から入るタイプなのである・・・。
そこで、Emacsと限らず他のものでもすべて音が出るようなソフトはないかと探してみた。
yingDev/Tickeys
Rust で書かれてるらしい。
インストール方法は homebrew cask で一発。
$ brew cask install tickeys  あとはシステム環境設定のアクセシビリティから許可するだけ。
起動したら QAZ123 とタイプすることで設定画面が開く。
音を選択出来るので、 Cherry G80-3000 ってやつにした。 良い音！たくさんタイプしたくなるので、コード書くのが捗ること間違いなし。
参考 Tickeys – メカニカルキーボードのタイプ音を堪能できるMacアプリ</description>
    </item>
    
    <item>
      <title>Mapping with &lt;nowait&gt; option in vim</title>
      <link>http://yukimemi.github.io/post/2016-08-09_mapping-with-nowait-option-in-vim/</link>
      <pubDate>Tue, 09 Aug 2016 09:58:11 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2016-08-09_mapping-with-nowait-option-in-vim/</guid>
      <description>vim でマッピングをする時に、便利なオプションがあることを最近知った。
それが &amp;lt;nowait&amp;gt; オプション。
例えば、よくやるキーマップの例としてこんなのがある。
nnoremap &amp;lt;silent&amp;gt; &amp;lt;ESC&amp;gt;&amp;lt;ESC&amp;gt; :&amp;lt;C-u&amp;gt;nohlsearch&amp;lt;CR&amp;gt;  エスケープ2回でハイライト消すっていうマッピング。
だけど、これを設定した状態で、コマンドウィンドウを &amp;lt;ESC&amp;gt; で閉じたい場合、&amp;lt;ESC&amp;gt; を押下しても、次のマッピングを待っている状態になってしまって、すぐに閉じることができない。
こんなマッピングをした場合。
au MyAutoCmd CmdwinEnter * nnoremap &amp;lt;silent&amp;gt;&amp;lt;buffer&amp;gt; &amp;lt;ESC&amp;gt; :q&amp;lt;CR&amp;gt;  この場合に、 &amp;lt;nowait&amp;gt; というオプションを追加することで、 &amp;lt;ESC&amp;gt; を押下したらすぐにコマンドウィンドウを閉じることができる。
au MyAutoCmd CmdwinEnter * nnoremap &amp;lt;silent&amp;gt;&amp;lt;buffer&amp;gt;&amp;lt;nowait&amp;gt; &amp;lt;ESC&amp;gt; :q&amp;lt;CR&amp;gt;  めちゃめちゃ便利。
僕の場合、コマンドウィンドウと、Uniteを閉じるのにこのオプションを使っている。
こんな感じ。
&amp;quot; Cmdwin. nnoremap : q:i vnoremap : q:A &amp;quot; nohlsearch. nnoremap &amp;lt;silent&amp;gt; &amp;lt;ESC&amp;gt;&amp;lt;ESC&amp;gt; :&amp;lt;C-u&amp;gt;nohlsearch&amp;lt;CR&amp;gt; &amp;quot; Escape cmd win. au MyAutoCmd CmdwinEnter * nnoremap &amp;lt;silent&amp;gt;&amp;lt;buffer&amp;gt;&amp;lt;nowait&amp;gt; &amp;lt;ESC&amp;gt; :q&amp;lt;CR&amp;gt; &amp;quot; Escape unite.</description>
    </item>
    
    <item>
      <title>JScript by ES2015 with webpack x gulp x babel</title>
      <link>http://yukimemi.github.io/post/2016-07-26_jscript-by-es2015-with-webpack-x-gulp-x-babel/</link>
      <pubDate>Tue, 26 Jul 2016 00:58:51 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2016-07-26_jscript-by-es2015-with-webpack-x-gulp-x-babel/</guid>
      <description>JScriptをES2015で書こう！！
・・・今更なJScriptだけれども、まだまだWindowsでは使えるはず。 いや、仕方なく仕事では使わなきゃいけない場面が多々ある。
最近はpowershellをよく使っていたけれども、書いてて楽しいのはやっぱりjavascriptの方が上。 でもどうせ書くなら、ES2015で書きたい！！
そこで、babelやらwebpackやらgulpやらを駆使してやってみた。
ディレクトリ構成はこんなの。
$ tree -I node_modules . ├── src │ ├── foo.js │ └── bar.js ├── dst │ ├── foo.cmd │ └── bar.cmd ├── .babelrc ├── package.json ├── gulpfile.babel.js └── webpack.config.babel.js  いろいろインストール。(こんだけやったか定かじゃないけど・・・
$ npm i -D babel babel-loader babel-preset-es2015-loose es3ify-webpack-plugin gulp gulp-cli gulp-convert-encoding gulp-eol gulp-header gulp-plumber gulp-rename gulp-watch webpack webpack-stream  package.json はこんな感じ。
 package.json  { &amp;quot;name&amp;quot;: &amp;quot;jscript&amp;quot;, &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;, &amp;quot;description&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;main&amp;quot;: &amp;quot;gulpfile.</description>
    </item>
    
    <item>
      <title>Super saiya Vim !</title>
      <link>http://yukimemi.github.io/post/2015-09-23_super-saiya-vim-/</link>
      <pubDate>Wed, 23 Sep 2015 14:54:51 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2015-09-23_super-saiya-vim-/</guid>
      <description>Vimでも超サイヤ人になりたい！
ってなわけでやってみた。
経緯としては、Windows環境でvimの起動がかなり遅かったため。
vimに導入したプラグイン数が多くなりすぎていたため、起動に時間がかかっていた。 そこで、起動時には基本的なプラグインのみ読み込み、後から必要に応じてpluginを追加で読み込むようにしてみた。
if has(&#39;vim_starting&#39;) if &amp;amp;compatible set nocompatible endif set runtimepath+=~/.cache/neobundle/neobundle.vim endif call neobundle#begin(expand(&#39;~/.cache/neobundle&#39;)) if neobundle#load_cache() call neobundle#load_toml(&#39;~/.vim/vim.d/neobundle_base.toml&#39;) call neobundle#load_toml(&#39;~/.vim/vim.d/neobundlelazy_base.toml&#39;, {&#39;lazy&#39; : 1}) NeoBundleSaveCache endif call neobundle#end() filetype plugin indent on nnoremap &amp;lt;silent&amp;gt; &amp;lt;Space&amp;gt;s :&amp;lt;C-u&amp;gt;call &amp;lt;SID&amp;gt;loadAllPlugins()&amp;lt;CR&amp;gt; function! s:loadAllPlugins() call neobundle#append() call neobundle#load_toml(&#39;~/.vim/vim.d/neobundle.toml&#39;) call neobundle#load_toml(&#39;~/.vim/vim.d/neobundlelazy.toml&#39;, {&#39;lazy&#39; : 1}) call neobundle#end() filetype plugin indent on source ~/.vim/vim.d/05_pluginsetting.vim echom &amp;quot;Suuuuuuuuuper !!!!!!!&amp;quot; endfunction  これで、起動時は最小限のpluginで爆速起動し、必要な時に &amp;lt;Space&amp;gt;s を押下することで超サイヤVimになれる。(全pluginをロードする)
遅かったWindows環境ではまだ試せていないが、New MacBook 12では、0.2sくらいの起動時間が0.15sにまで短縮された・・・！</description>
    </item>
    
    <item>
      <title>Set up Macbook in Ansible</title>
      <link>http://yukimemi.github.io/post/2015-07-26_set-up-macbook-in-ansible/</link>
      <pubDate>Sun, 26 Jul 2015 16:08:23 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2015-07-26_set-up-macbook-in-ansible/</guid>
      <description>せっかくMacbookを新調したので、セットアップを今までのオレオレスクリプトから、ansibleに移行した。
先人の参考になりまくる記事がいっぱいあるので、けっこう簡単に出来た。
yukimemi/ansible-playbook
参考記事だと、ansible-galaxyで、事前にhomebrewパッケージをインストールしなきゃいけない みたいに書いてあるけど、実際は不要だった。
べんりだansible。 Mac以外にも対応出来るように今後は拡張していきたい。
参考 AnsibleでHomebrew, Cask, Atomエディターのパッケージを管理する - Qiita
MacだってAnsibleで構成管理したい！ - Qiita
Mac の開発環境構築を自動化する (2015 年初旬編) - t-wadaのブログ</description>
    </item>
    
    <item>
      <title>New MacBook 12</title>
      <link>http://yukimemi.github.io/post/2015-07-26_new-macbook-12/</link>
      <pubDate>Sun, 26 Jul 2015 15:17:39 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2015-07-26_new-macbook-12/</guid>
      <description>ついに・・・ついに買ってしまった。New MacBook 12インチ。
今まで使ってたMacbook Air Late 2010のキーボードが急に反応しなくなってしまったため、 急遽New Macbook 12インチを新調した。
なんにもカスタマイズせずに一番安いのをヤマダ電機で購入した。
ヤマダのポイントが10パーついて、14000もポイントがある。 何に使おうか・・・。
肝心のMacbookの使い勝手は、もう文句なしに素晴らしい。 心配してた熱も特になし。
驚いたのが、こんなに薄いのに、思った以上に良い音が出るということ。
性能も十分だしすばらしい。ほんとAppleはすごい。</description>
    </item>
    
    <item>
      <title>PalmDetect in Ubuntu</title>
      <link>http://yukimemi.github.io/post/2015-05-10_palmdetect-in-ubuntu/</link>
      <pubDate>Sun, 10 May 2015 08:57:44 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2015-05-10_palmdetect-in-ubuntu/</guid>
      <description>MacBook AirにUbuntu 15.04をインストールした。 だいたい使いやすくはなっているのだけど、たまにキーボード入力をしている時にタッチパッドが誤反応してしまう時があった。
そこで、手のひら検出？とかいうのを入れてみることにした。
以下のファイルを作成する。
$ vim ~/.config/autostart/synclient.desktop  内容は以下の通り
[Desktop Entry] Type=Application Exec=synclient PalmDetect=1 Hidden=false NoDisplay=false X-GNOME-Autostart-enabled=true Name[ja]=synclient(PalmDetect) Name=synclient(PalmDetect) Comment[ja]= Comment=  Superキーを押して出てくる検索メニューから「自動起動するアプリケーション」を選択して、そこで記載するのと同じ。
参考 安全にsynclientでUbuntuのタッチパッド設定を変更する - Qiita</description>
    </item>
    
    <item>
      <title>Use gomi instead of rm</title>
      <link>http://yukimemi.github.io/post/2015-05-04_use-gomi/</link>
      <pubDate>Mon, 04 May 2015 17:14:11 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2015-05-04_use-gomi/</guid>
      <description>rmを安全に行うツールとして、Macでは「rmtrash」、Linuxでは「trash-cli」を使ってきたけど、最近Golangで「gomi」というツールが作成されたとのことなので使用してみた。 とても便利。
インストールはgo get。
$ go get -u github.com/b4b4r07/gomi  さっそくaliasした。
$ alias rm=&#39;gomi&#39;  </description>
    </item>
    
    <item>
      <title>Mayu for IME off in vim</title>
      <link>http://yukimemi.github.io/post/2015-05-02_mayu-for-ime-off-in-vim/</link>
      <pubDate>Sat, 02 May 2015 22:59:12 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2015-05-02_mayu-for-ime-off-in-vim/</guid>
      <description>vimを使っていて困るのがIMEの制御。特に、ノーマルモードに戻った時に自動でIMEがOFFになってくれないと、画面に「jっっっｘ」とかがあふれる。 Macでは、「karabiner」というソフトを使って、「Escape」もしくは、「Ctrl + [」を押下した時に自動でIMEをOFFにすることが出来ていた。
Linuxでも同じことが出来ないかといろいろググってはみたものの、意外とこれ！ってのが見つからない。 そんな中、一応要望を満たせるのが、「Mayu」というソフトだった。
Windowsで「窓使いの憂鬱」と呼ばれてたソフトで、Linuxにも対応してるっぽい。
設定自体は単純なんだけど、キーボードのキーコードを全部定義しなきゃいけないみたいで、それがめんどくさそうだった。 幸いにも、全部をスキャンしたファイルをアップしてくれている人がいたので、使用させてもらった。 一部、MacBookAirのキーコードに対応していなかったものがあったため、少し改変している。
Mayuのインストール Mayuはソースコードのみ配布されているので、自分でビルドする必要がある。 Ubuntu 15.04では以下の通りにやるとビルド出来た。
$ ghq get https://github.com/kenhys/mayu.git $ cd ~/.ghq/src/github.com/kenhys/mayu $ sudo aptitude install build-essential libboost-iostreams-dev libudev-dev libusb-1.0-0-dev $ ./configure --with-boost-libdir=/usr/lib/x86_64-linux-gnu/ $ make $ sudo make install $ sudo chmod +s /usr/local/bin/mayu  mayuはroot権限で実行する必要があり、systemd経由で自動起動させるためにsetuidをたてている。 本当はvisudoとかでmayuのみパスワードなしsudo出来るようにしたりとかのがいいのかもしれないけど、めんどくさいので・・・。
fcitx設定 今回やりたいのは、「Escape」を押下した時にIMEをオフにする、もしくは「Crtl-[」を押下した時にIMEをオフにするということ。 前提として、Ubuntu 15.04では、IMEとしてfcitx-mozcを使用している。
それから、fcitxの設定で、「入力メソッドをオンに」を「Hangul」(かなキー)、入力メソッドをオフ」に「Hangulhanja」(英数キー)を割り当てる。
Mayu設定 次に、mayuの設定を書く。上記のようにfcitxの設定をしているのであれば、mayuの設定としては以下の通り。
def key Esc Escape = 0x01 def key Eisu = 0x7b key Esc = Esc Eisu key C-OpenBracket = C-OpenBracket Eisu  「Escape」が押された時に、「Escape」、「英数」を押し、「Ctrl-[」が押された時に、「Ctrl-[」、「英数」を押すという設定。</description>
    </item>
    
    <item>
      <title>Guake terminal in ubuntu</title>
      <link>http://yukimemi.github.io/post/2015-05-02_guake-terminal/</link>
      <pubDate>Sat, 02 May 2015 22:03:13 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2015-05-02_guake-terminal/</guid>
      <description>macでiTerm2を使っていたので、同じように使えるterminalがないか探していたところ、あんまこれ！ってのが見つからなかったので、昔使ってたguakeを入れた。けっこう普通につかえて便利。
$ sudo apt-get install guake  デフォルトでは、「F12」で起動する。
おすすめ設定は、こんな感じ。
 全般   スクロール   外観  タブバーを表示しないようにして、start fullscreenにして、スクロールバーを非表示にして、透明度を下から2個目くらいにしたらちょうどいい感じ。
あとは、fontをRicty for Powerlineにする。
Ricty for Powerlineのインストールは以下の通り。
#!/bin/bash mkdir -p ~/tmp mkdir -p ~/.fonts pushd ~/tmp sudo apt-get install fontforge wget http://levien.com/type/myfonts/Inconsolata.otf wget http://iij.dl.sourceforge.jp/mix-mplus-ipa/59022/migu-1m-20130617.zip unzip migu-1m-20130617.zip git clone https://github.com/yascentur/Ricty.git pushd Ricty ./ricty_generator.sh ~/tmp/Inconsolata.otf ~/tmp/migu-1m-20130617/migu-1m-regular.ttf ~/tmp/migu-1m-20130617/migu-1m-bold.ttf mv Ricty*.ttf ~/.fonts popd git clone https://github.com/Lokaltog/vim-powerline.git fontforge -lang=py -script ./vim-powerline/fontpatcher/fontpatcher $HOME/.fonts/Ricty-Regular.ttf fontforge -lang=py -script .</description>
    </item>
    
    <item>
      <title>Install Ubuntu 15.04 to MacBook Air (11-inch, Late 2010)</title>
      <link>http://yukimemi.github.io/post/2015-05-02_install-ubuntu-to-macbook-air/</link>
      <pubDate>Sat, 02 May 2015 09:23:30 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2015-05-02_install-ubuntu-to-macbook-air/</guid>
      <description>使ってるMacBook Airが最近遅くて耐えられなくなってきたので、Ubuntuに乗り換えてみた。
nvidiaのドライバ関係でいろいろ大変だったのでメモ。
Install Usbメモリの作成 $ sudo dd if=./ubuntu-15.04-desktop-amd64.iso of=/dev/sdb bs=4M  Ubuntu インストール nvidiaのグラフィックドライバをインストールする場合、grubがefiモードじゃなくてbiosモードでインストールされる必要があるっぽい。 そこで、通常とはちょっと違う方法でインストールする。
まず、最初の選択で、 &amp;ldquo;Try Ubuntu without installing it&amp;rdquo; を選ぶ。 その後、 &amp;ldquo;Ctrl + Alt + T&amp;rdquo; を押して端末を起動し、インストーラを起動する。
$ sudo ubiquity  それから、 &amp;ldquo;それ以外&amp;rdquo; ってのを選んで、自分でパーティションを作成する。 必要なパーティションは以下の3つ
 予約されたBIOSブート領域: 1M ext4(/): swap以外全部 swap: 2048M  その後はそのままインストールを続ける。 全部終わると再起動が促されるが、そのまま再起動せずに、端末を起動し、grubをインストールする。
$ sudo mount /dev/sda2 /mnt # rootパーティション $ sudo grub-install --root-directory=/mnt /dev/sda $ sudo grub-install --root-directory=/mnt --recheck /dev/sda $ sudo mount --bind /dev /mnt/dev $ sudo mount --bind /dev/pts /mnt/dev/pts $ sudo mount --bind /proc /mnt/proc $ sudo mount --bind /sys /mnt/sys $ sudo chroot /mnt $ update-grub $ exit  usbをさしたままだと、sdbにはインストールできないとかなんとかのエラーが出るけど、むし。 コマンドが全部終わったら再起動してusbを抜く。</description>
    </item>
    
    <item>
      <title>vimperator colorscheme</title>
      <link>http://yukimemi.github.io/post/2015-03-02_vimperator-colorscheme/</link>
      <pubDate>Mon, 02 Mar 2015 02:00:14 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2015-03-02_vimperator-colorscheme/</guid>
      <description>vimperatorでcolorschemeを使う方法。
自分で作ってもいいけど、大変なので・・・
リポジトリクローン ghq については、この記事で。
$ ghq get https://github.com/vimpr/vimperator-colors.git  シンボリックリンク $ ln -sfn ~/.ghq/src/github.com/vimpr/vimperator-colors ~/.vimperator/colors  .vimperatorrc編集 colorscheme sweets_snaka  かっこいい！！
参考: vimpr/vimperator-colors</description>
    </item>
    
    <item>
      <title>hello hugo</title>
      <link>http://yukimemi.github.io/post/2015-02-15_hello-hugo/</link>
      <pubDate>Sun, 15 Feb 2015 10:28:27 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/post/2015-02-15_hello-hugo/</guid>
      <description>これまでいろいろ静的サイトジェネレーターを試してきた。
Tinkerer roots そして今回はgolang製の hugo
hugo 流行りに乗ってみたいってのもあるけど、なによりサイト生成がはやい！！
これだけでも乗り換える価値があると思う。
参考 OctopressからHugoへ移行した
WordPress から Hugo に乗り換えました</description>
    </item>
    
    <item>
      <title>about</title>
      <link>http://yukimemi.github.io/about-time/</link>
      <pubDate>Thu, 29 Jan 2015 23:15:03 +0900</pubDate>
      
      <guid>http://yukimemi.github.io/about-time/</guid>
      <description>This site is yukimemi&amp;rsquo;s blog.</description>
    </item>
    
    <item>
      <title>Set cursorline as needed</title>
      <link>http://yukimemi.github.io/post/2014-08-05_set-cursorline-as-needed/</link>
      <pubDate>Tue, 05 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2014-08-05_set-cursorline-as-needed/</guid>
      <description>これまで、 &amp;lsquo;cursorline&amp;rsquo; を必要な時にだけ有効にする - 永遠に未完成 を参考に、cursorlineの設定をしていたけど、時々cursorlineがずっと表示されたままになる現象が発生していた。
よくよく調べてみると、一度 CursorHold イベントを発生させ(set cursorline)、その後に別Windowへ移動し、さらに &amp;lt;C-^&amp;gt; でもとのバッファに戻ったときに、 s:cursorline_lock 変数が「0」のままとなり、その後 CursorMoved イベントが発生してもずっと set nocursorline されなくなるようだった。
そこで、 Lingr のvim部屋で初めて質問してみた。
そしたらあっさりと答えを教えてもらえた。vimmerは思ってたよりこわくなかった。よかた。
&amp;lt;C-^&amp;gt; では、 WinEnter イベントは発生しないが、 BufEnter イベントは発生するらしい。 また、僕は、 nnoremap : q:i のようにして、コマンドラインウィンドウを使うようにしているのだが、この場合も上記と同様に、cursorlineがずっと消えない事象が発生していた。 そこで、thincaさんの 設定 を以下のように、変更した。
au MyAutoCmd CursorMoved,CursorMovedI * call s:auto_cursorline(&#39;CursorMoved&#39;) au MyAutoCmd CursorHold,CursorHoldI * call s:auto_cursorline(&#39;CursorHold&#39;) au MyAutoCmd WinEnter,BufEnter,CmdwinLeave * call s:auto_cursorline(&#39;WinEnter,BufEnter,CmdwinLeave&#39;) au MyAutoCmd WinLeave * call s:auto_cursorline(&#39;WinLeave&#39;) let s:cursorline_lock = 0 function! s:auto_cursorline(event) if a:event ==# &#39;WinEnter,BufEnter,CmdwinLeave&#39; setlocal cursorline setlocal cursorcolumn let s:cursorline_lock = 2 elseif a:event ==# &#39;WinLeave&#39; setlocal nocursorline setlocal nocursorcolumn elseif a:event ==# &#39;CursorMoved&#39; if s:cursorline_lock if 1 &amp;lt; s:cursorline_lock let s:cursorline_lock = 1 else setlocal nocursorline setlocal nocursorcolumn let s:cursorline_lock = 0 endif endif elseif a:event ==# &#39;CursorHold&#39; if &amp;amp;updatetime &amp;gt;= 4000 setlocal cursorline setlocal cursorcolumn endif let s:cursorline_lock = 1 endif endfunction  ついでに cursorcolumn も追加しといた。 また、 TweetVim や、 calendar.</description>
    </item>
    
    <item>
      <title>Add --runcmd option to coffee-script-on-jscript</title>
      <link>http://yukimemi.github.io/post/2014-07-15_add---runcmd-option-to-coffee-script-on-jscript/</link>
      <pubDate>Tue, 15 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2014-07-15_add---runcmd-option-to-coffee-script-on-jscript/</guid>
      <description>先日の 記事 のthincaさんフォーク版、僕々仕様のWindows上でのCoffeeScriptコンパイラに --runcmd オプションを加えた。
yukimemi/coffee-script-on-jscript
&amp;gt; coffee Usage: coffee [options] path/to/script.coffee -b, --bare compile without the top-level function wrapper -c, --compile compile to JavaScript and save as .js files --encoding character encoding used by source files -e, --eval compile a string from the command line -h, --help display this help message -j, --join concatenate the scripts before compiling -n, --nodes print out the parse tree that the parser produces -o, --output set the directory for compiled JavaScript -p, --print print the compiled JavaScript to stdout -s, --stdio listen for and compile scripts over stdio -t, --tokens print the tokens that the lexer produces -v, --version display CoffeeScript version -w, --watch watch scripts for changes, and recompile -r, --runcmd run the compiled scripts as JScript  最後の行のやつ。</description>
    </item>
    
    <item>
      <title>CoffeeScript on Windows as wsh</title>
      <link>http://yukimemi.github.io/post/2014-07-14_coffeescript-on-windows-as-wsh/</link>
      <pubDate>Mon, 14 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2014-07-14_coffeescript-on-windows-as-wsh/</guid>
      <description>長い間、Windowsでcoffeescriptをwshとして記述する方法を模索していたけど、ようやく解が見つかった！！
thinca/coffee-script-on-jscript
thincaさん作成のcoffeescriptコンパイラ。Windowsで動く。nodejsもいらず、バッチファイル1つ coffee.bat と、公式の coffee-script.js だけで動く。
使用方法 &amp;gt; ghq get https://github.com/thinca/coffee-script-on-jscript.git  or
&amp;gt; git clone https://github.com/thinca/coffee-script-on-jscript.git  ghq があるなら上で。
後は普通のcoffeescriptコンパイラと同じオプションがだいたい使えるようなので、普通にコンパイルするのであれば
&amp;gt; coffee -c hello.coffee  とかで hello.js に変換される。
watch オプションもあるみたいなので、
&amp;gt; coffee -cw hello.coffee  としておくと、 hello.coffee を更新するたびに自動でコンパイルしてくれる。便利。
他のオプションは、 coffee.bat に何も引数をつけずに実行するとhelpで表示される。
&amp;gt; coffee Usage: coffee [options] path/to/script.coffee -b, --bare compile without the top-level function wrapper -c, --compile compile to JavaScript and save as .js files --encoding character encoding used by source files -e, --eval compile a string from the command line -h, --help display this help message -j, --join concatenate the scripts before compiling -n, --nodes print out the parse tree that the parser produces -o, --output set the directory for compiled JavaScript -p, --print print the compiled JavaScript to stdout -s, --stdio listen for and compile scripts over stdio -t, --tokens print the tokens that the lexer produces -v, --version display CoffeeScript version -w, --watch watch scripts for changes, and recompile  jscriptをバッチとして実行 上記までで、 coffeescript を jscript に変換することは簡単に出来るんだけど、どうせなら jscript からさらにバッチとして実行出来る状態に変換したい。 jscript をバッチとして実行するには、まさに coffee.</description>
    </item>
    
    <item>
      <title>roots simple pagination</title>
      <link>http://yukimemi.github.io/post/2014-07-09_roots-simple-pagination/</link>
      <pubDate>Wed, 09 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2014-07-09_roots-simple-pagination/</guid>
      <description>rootsは非常にシンプルで良いのだが、シンプルが故に通常のブログだと当たり前な部分を自分で実装しなければいけないところがある。
その一つが、ページネーション。
rootsでブログテンプレートを作成した場合、トップページはページネーションされず、書いていったブログ記事が全部リストで並ぶことになる。
まぁそんなたいした量を書いてないんで問題ないのだけれども、一応ブログとしてページネーションくらいはあったほうがいいと思い、実装方法を探してみた。
rootsは静的サイトジェネレーターなので、通常だとjadeの記法などでコンパイル時に出来るんだろうけど、今回はjqueryで簡単に出来る simplePagination.js というものが見つかったので、それを追加してみた。
インストール まず、追加するのにはbowerを使った。 ちなみにローカルにインストールしたbowerを使う方法は、前の記事 を参照。
$ npm install bower --save-dev  事前準備として、bowerのコンポーネントがインストールされる先を変更しておく。
roots のルートで、
$ vim .bowerrc  し、以下を記載。
{ &amp;quot;directory&amp;quot;: &amp;quot;assets/bower_components&amp;quot; }  その後、bowerにて、 simplePagination.js をインストールする。
$ bower install jquery.simplePagination --save  これで、 assets/bower_components 配下に保存される。
simplePagination.js 設定 jade側の設定 まずは、ページネーションの配置。
$ vim views/layout.jade  --- 省略 --- #main != content .pagination --- 省略 ---  divのclassで設定。単純に pagination というclassにて、divを配置しただけ。
それから、stylusでの設定がしやすいように、ブログ記事のリストにclassを設定しておく。
$ vim views/index.jade  ul#posts - each post in sort(site.</description>
    </item>
    
    <item>
      <title>mosh error No such file or directory</title>
      <link>http://yukimemi.github.io/post/2014-07-06_mosh-error-no-such-file-or-directory/</link>
      <pubDate>Sun, 06 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2014-07-06_mosh-error-no-such-file-or-directory/</guid>
      <description>mosh というmobile-shelllを導入してみたところ、「No such file or directory」という エラーが発生して使えなかった・・・。
原因は結局よくわからなかったんだけど、とりあえず使えるようになったので、一応メモとして残しとこ。
mosh install 環境は Mac OSX Mavericks。Homebrewで簡単にインストール出来た。
$ brew install mosh  昔は mobile-shelll だったみたいだけど、今は mosh でインストール出来る。 クライアント側とサーバ側両方インストールしておく必要あり。
使い方 普通の ssh を mosh に変えるだけ。
$ ssh yukimemi@yukimemi-my-host.com  ↓
$ mosh yukimemi@yukimemi-my-host.com  だけど、なぜか、こんなエラーが出て使えなかった・・・。
$ mosh yukimemi@yukimemi-my-host.com zsh: No such file or directory ssh_exchange_identification: Connection closed by remote host /usr/local/bin/mosh: Did not find remote IP address (is SSH ProxyCommand disabled?).  なんかzshが見つかんない？みたいなエラー。 zshが悪いのかと思い、bashからやってみてもエラーになった。</description>
    </item>
    
    <item>
      <title>Git directory deploy !</title>
      <link>http://yukimemi.github.io/post/2014-07-02_git-directory-deploy-/</link>
      <pubDate>Wed, 02 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2014-07-02_git-directory-deploy-/</guid>
      <description>roots のデプロイ手順。
僕の環境では、まず drafts ブランチで書いて、 master ブランチでpushして githubへ更新という流れ。 その際、 roots では、ビルド結果を public というディレクトリに出力するので そのディレクトリだけをpushしたい。 gitで管理している中の、ある一部のディレクトリのみをpushしたい場合は、 git subtree push という のが使えるらしいんだけど、参考にしたサイトでは違うアプローチをとっているみたい。
X1011/git-directory-deploy
rootsに限らず、静的サイトジェネレーターを使う場合はけっこう使えると思う。
これ をダウンロード $ wget https://github.com/X1011/git-directory-deploy/raw/master/deploy.sh &amp;amp;&amp;amp; chmod +x deploy.sh  git-directory-deployの設定 以下の部分を必要に応じて書き換え。
deploy_directory=public deploy_branch=master #if no user identity is already set in the current git environment, use this: default_username=yukimemi default_email=yukimemi@gmail.com #repository to deploy to. must be readable and writable. repo=origin  初回一度だけ実行 $ git --work-tree public checkout --orphan master $ git --work-tree public rm -rf &amp;quot;*&amp;quot; $ git --work-tree public add --all $ git --work-tree public commit -m &amp;quot;initial publish&amp;quot; $ git push -f origin public $ git symbolic-ref HEAD refs/heads/drafts &amp;amp;&amp;amp; git reset --mixed  デプロイの仕方 まずは、 drafts ブランチですべてコミットしておく。(未コミットが残っているとエラーになる。) それから、 roots でコンパイル。 あとは、ダウンロードした deploy.</description>
    </item>
    
    <item>
      <title>direnv for npm local commands</title>
      <link>http://yukimemi.github.io/post/2014-07-02_direnv-for-npm-local-commands/</link>
      <pubDate>Wed, 02 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2014-07-02_direnv-for-npm-local-commands/</guid>
      <description>通常、 npm で実行コマンドをインストールするときは、以下のようにグローバルオプションを つけてインストールすることが多いと思う。
$ npm install -g gulp  だけど、これではプロジェクトごとに違うバージョンを使いたい！などの場合にこまる。 そこで direnv 。
これを使うとあるディレクトリでは、「〜〜する」というのが簡単に出来る。
導入方法 まず、 direnv はgoを使うので、goをインストールしておく。
$ brew install go --cross-compile-common  以下を .zshenv に記載。
# direnv if which go &amp;gt; /dev/null; then if [ ! -d $HOME/.direnv ]; then git clone https://github.com/zimbatm/direnv ~/.direnv pushd ~/.direnv make install popd fi eval &amp;quot;$(direnv hook zsh)&amp;quot; fi  あとはシェルを再起動したらインストール完了。
使い方 プロジェクトのディレクトリでローカルにnpmのコマンドをインストールする。
$ npm install gulp  ローカルにインストールした場合、通常以下の場所に実行コマンドが配置される。
$ ls node_modules/.</description>
    </item>
    
    <item>
      <title>All You Need Is Peco</title>
      <link>http://yukimemi.github.io/post/2014-06-29_all-you-need-is-peco/</link>
      <pubDate>Sun, 29 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2014-06-29_all-you-need-is-peco/</guid>
      <description>最近 peco がかなり流行りっぽい。 そこで導入してみた。思ったより使い心地よくて、 zaw から乗り換えた。
導入手順 homebrewでgoをインストール。
$ brew install go --cross-compile-common  .zshenv に以下を記載。
# go export GOPATH=$HOME/.go export PATH=$GOPATH/bin:$PATH [ ! -d $GOPATH ] &amp;amp;&amp;amp; mkdir $GOPATH if which go &amp;gt; /dev/null; then export GOROOT=$(go env GOROOT) # ghq go get github.com/motemen/ghq git config --global ghq.root ~/.ghq # peco go get github.com/peco/peco/cmd/peco # gh-open go get github.com/typester/gh-open fi  .zshenv を読み込み直す
$ source ~/.zshenv  インストール完了。</description>
    </item>
    
    <item>
      <title>roots new post command</title>
      <link>http://yukimemi.github.io/post/2014-06-26_roots-new-post-command/</link>
      <pubDate>Thu, 26 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2014-06-26_roots-new-post-command/</guid>
      <description>Tinkererでは、 tinker -p &amp;quot;hogehoge&amp;quot; で、新しい記事を作成することが出来た。 roots でも同じことがしたかったので、コマンドを作ってみた。
#!/bin/bash # posts dir postsDir=posts # title echo -n &amp;quot;title: &amp;quot; read title postFile=${postsDir}/$(date +%Y-%m-%d)_${title}.jade cat &amp;lt;&amp;lt; EOT &amp;gt;&amp;gt; &amp;quot;${postFile}&amp;quot; --- title: ${title} date: $(date &amp;quot;+%Y/%m/%d %H:%M&amp;quot;) layout: ../views/_single_post.jade --- :markdown // vim: ft=markdown EOT  これを pn というファイル名でpathの通った場所に保存すると、
$ pn title: hogehoge  とプロンプトが表示され、タイトルを打ち込むことで新しいブログ記事を作成出来る。 便利。</description>
    </item>
    
    <item>
      <title>roots install</title>
      <link>http://yukimemi.github.io/post/2014-06-25_roots-install/</link>
      <pubDate>Wed, 25 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2014-06-25_roots-install/</guid>
      <description>今までブログはTinkererを使用していたけど、これからは、 roots で書くことにしよう。
roots は、静的サイトジェネレーター。nodeで動く。 特徴としては、以下の形式で作成出来ること。
 スクリプト -&amp;gt; coffeescript HTML -&amp;gt; jade CSS -&amp;gt; stylus  しかも、ライブリロードが標準で組み込まれているので、これが非常に便利。 jade ファイルを保存したら、自動でブラウザが更新され、すぐ確認出来る。
ブログ作成手順 1. npmでグローバルにインストール $ npm install -g roots  2. ブログテンプレートでプロジェクト作成 $ roots new yukimemi.github.io --blog  これでブログ完成。
3. roots コマンドでコンパイル &amp;amp; ウォッチ $ cd yukimemi.github.io $ roots watch  自動的にコンパイルが動き、 public ディレクトリにコンパイル結果が入り、さらにport 1111でサーバ を起動してくれ、さらにデフォルトのブラウザで自動的に開いてくれる。(至れり尽くせり)
4. ブログ記事を修正 $ cdk posts $ vim hello_world.jade  修正して保存すると、ブラウザが自動でリロードされ、すぐさま修正結果を確認出来る。 すごい・・・。
参考: Node.js - 静的サイトジェネレーター「roots」 - Qiita</description>
    </item>
    
    <item>
      <title>Second roots</title>
      <link>http://yukimemi.github.io/post/2014-06-20-second_post/</link>
      <pubDate>Fri, 20 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2014-06-20-second_post/</guid>
      <description>roots
やっぱりいろいろ難しい。
とりあえず、 subtree push が便利っぽい。 がんばる。</description>
    </item>
    
    <item>
      <title>First roots</title>
      <link>http://yukimemi.github.io/post/2014-06-19-first_post/</link>
      <pubDate>Thu, 19 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2014-06-19-first_post/</guid>
      <description>はじめての「roots」
Markdown でもブログが書けるらしい。
移行しよかな。 ライブリロードがあるのがいいね。</description>
    </item>
    
    <item>
      <title>tmuxで一時的にpaneを最大化する</title>
      <link>http://yukimemi.github.io/post/2014-06-01-tmux_prefix_z/</link>
      <pubDate>Sun, 01 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2014-06-01-tmux_prefix_z/</guid>
      <description>知らんかった。便利
tmux 1.8 以降だと、 prefix z で最大化をトグルできるみたい。
tmux で一時的に pane を最大化する - sorry, uninuplemented:
ちなみに、vimでは、以下のような設定で似たようなことも出来るみたい。
nnoremap so &amp;lt;C-w&amp;gt;_&amp;lt;C-w&amp;gt;|  2個目の &amp;lt;C-w&amp;gt; と | の間には、 &amp;lt;C-v&amp;gt; があり。( &amp;lt;C-v&amp;gt; を2回入力する)
トグルではないけど。</description>
    </item>
    
    <item>
      <title>Tinkerer テーマ変更</title>
      <link>http://yukimemi.github.io/post/2014-05-19-change_theme/</link>
      <pubDate>Mon, 19 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2014-05-19-change_theme/</guid>
      <description>Tinkerer のテーマを変えた。 tinkerturquoise ていうテーマ
naoiwata さん作成。 使用させて頂きます。
インストールの仕方は以下のページの通り。
sphinxjp.themes.tinkerturquoise 0.2.21 : Python Package Index</description>
    </item>
    
    <item>
      <title>haskellでgitstatus</title>
      <link>http://yukimemi.github.io/post/2014-05-15-haskell_gitstatus/</link>
      <pubDate>Thu, 15 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2014-05-15-haskell_gitstatus/</guid>
      <description>前に Go言語で 「すべてのディレクトリで git statusする」 という記事を書いた。
今度は、 haskell で同じようなのを書いてみた。
import System.IO import System.Process import System.Directory import Control.Exception import System.FilePath getAllFiles :: FilePath -&amp;gt; IO [String] getAllFiles dir = do contents &amp;lt;- getDirectoryContents dir `catch` (\(SomeException e) -&amp;gt; const (return []) e) let contents&#39; = [dir &amp;lt;/&amp;gt; path | path &amp;lt;- contents, notElem path [&amp;quot;.&amp;quot;, &amp;quot;..&amp;quot;]] contents&#39;&#39; &amp;lt;- mapM getAllFiles contents&#39; return $ contents&#39; ++ concat contents&#39;&#39; takeLast list n = reverse .</description>
    </item>
    
    <item>
      <title>PowerShell Markdown を Wordに変換する</title>
      <link>http://yukimemi.github.io/post/2014-04-17-md2docx/</link>
      <pubDate>Thu, 17 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2014-04-17-md2docx/</guid>
      <description>仕事でwordを使うことが多々あるのだが、正直いってwordは使いづらい！ 勝手にレイアウトが変わったりスタイルが変わったり・・・思い通りにならないこと山のごとし。
なんとかならんもんか！とGoogle先生に聞いたところ、Markdownを使ってdocxを作成出来るものがあるじゃないですか。
Pandoc - About pandoc
ただ、pandocは基本htmlやlatex向きに作成されているのか、wordで思い通りのレイアウトには出来なかった。 特にスタイルとか・・・。
そこで、Markdownからdocxに変換するスクリプトを書いた。
yukimemi/md2docx
詳しくは README に記載してあるが、見出しやリストや画像や改ページ等には対応しています。
簡単に試すなら、上記リポジトリにある、 md2docx.cmd と sample.md をダウンロードし、コマンドプロンプトより、
&amp;gt; md2docx.cmd sample.md  と実行すれば、あら不思議。sample.docxが出来ているはずです。
Windows標準のPowerShellで書いてあるので、Windowsを使ってる人なら誰でもMarkdownからdocxに変換出来ます。
pandocだと、わざわざpandocをインストールしなくてはいけないので、これからプロジェクトの仕様書はMarkdownで書く！なんてことは出来ませんが、このPowerShellならそれも可能・・・なはず。
ぜひブラッシュアップして本当に使えるようにしたいので、プルリクお願いします＞＜</description>
    </item>
    
    <item>
      <title>golang git 管理のすべてのディレクトリで 「git status」する</title>
      <link>http://yukimemi.github.io/post/2014-03-22-gitstatus/</link>
      <pubDate>Sat, 22 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2014-03-22-gitstatus/</guid>
      <description>Go言語が流行りっぽいので、Goを使って、カレントディレクトリ配下の、gitで管理されているすべてのディレクトリで「git status」を実行するプログラムを書いてみた。 別にGoで書く必要はないんだけど・・・。
yukimemi/gitstatus
$ gitstatus yukimemi  みたいにすると、「gitstatus」を実行したディレクトリ配下で、「git remote -v」に「yukimemi」が含まれるものを対象に、「git status」を実行して出力する。引数を指定しなければ、すべてのディレクトリで。
出力イメージはこんな感じ。
root /Users/yukimemi -------------------------------------------------------------------------------- ★ /Users/yukimemi/.oh-my-zsh On branch master Your branch is up-to-date with &#39;origin/master&#39;. Changes not staged for commit: (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed) (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory) modified: templates/zshrc.zsh-template no changes added to commit (use &amp;quot;git add&amp;quot; and/or &amp;quot;git commit -a&amp;quot;) -------------------------------------------------------------------------------- -------------------------------------------------------------------------------- ★ /Users/yukimemi/Documents/git/go On branch master Your branch is up-to-date with &#39;origin/master&#39;.</description>
    </item>
    
    <item>
      <title>vim で powershell を書く！</title>
      <link>http://yukimemi.github.io/post/2014-02-08-powershell_make_cmd/</link>
      <pubDate>Sat, 08 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2014-02-08-powershell_make_cmd/</guid>
      <description>この記事は、 Vim Advent Calendar 2013 70日目の記事になります。
vim で powershell を書く時の設定です。
まず、 syntax と indent 。 これは、以下のプラグインでOK。(なんかインデントは変だけど・・・)
NeoBundleLazy &#39;PProvost/vim-ps1&#39;  それから、 vim から実行するために、 quickrun を入れます。(これは定番ですね！)
NeoBundleLazy &#39;thinca/vim-quickrun&#39;  ちょっと前までは、powershell でquickrunするためには、設定が必要だったけど、最近オフィシャルに対応されるようになったみたいです。
参考: VimとPowerShell - Qiita
これで、powershellを書いてる時に、デフォルトだと &amp;lt;Leader&amp;gt;r で実行できます。
さらに、おもむろに以下のファイルを作成して、 header.cmd というファイル名で保存。
@echo off pushd &amp;quot;%~dp0&amp;quot; &amp;gt; nul set tm=%time: =0% set ps1file=%~n0___%date:~-10,4%%date:~-5,2%%date:~-2,2%_%tm:~0,2%%tm:~3,2%%tm:~6,2%%tm:~9,2%.ps1 for /f &amp;quot;usebackq skip=10 delims=&amp;quot; %%i in (&amp;quot;%~f0&amp;quot;) do @echo %%i &amp;gt;&amp;gt; &amp;quot;%ps1file%&amp;quot; powershell -NoProfile -ExecutionPolicy unrestricted -File &amp;quot;%ps1file%&amp;quot; %* del &amp;quot;%ps1file%&amp;quot; popd &amp;gt; nul pause exit /b %ERRORLEVEL% # ========== do ps1 file as a dosbatch ==========  そして、以下の設定を .</description>
    </item>
    
    <item>
      <title>vim indentLine で見やすいインデントを</title>
      <link>http://yukimemi.github.io/post/2014-01-18-vim_indentline/</link>
      <pubDate>Sat, 18 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2014-01-18-vim_indentline/</guid>
      <description>vim には、見やすい定番のインデントプラグインとして、 nathanaelkane/vim-indent-guides がある。
しかし、最近、 Yggdroot/indentLine というプラグイン が、 オススメなVimのプラグイン紹介 - RailsとRubyとVimのブログ で紹介されていたので、乗り換えた。
シンプルでかっこいい。 それに、 vim-indent-guides は、 indent をタブで記述してあるファイルの時の表示がタブ全部が色塗られてしまって見難い。
個人的にはタブを使用することはなくて、スペースを使用するから問題ないのだけれども・・・。
その点、 indentLine では、スペースしか対応してなく、タブの場合は何もしない。
README にも記載があるが、タブで同じことやるためには、 .vimrc に、以下の記載を加えればいい。
set list listchars=tab:\¦\  最後にスペースが入っていることに注意。
こうすると、スペースの場合とほぼ同じように表示される。
ただ、一つ目のインデントからも表示されるのが不満。2行目からのみ表示されるように出来ないものか・・・。
また、インデントを除外したい場合は、その filetype を設定してやればいいみたい。
let g:indentLine_fileTypeExclude = [&#39;help&#39;, &#39;nerdtree&#39;, &#39;calendar&#39;, &#39;thumbnail&#39;, &#39;tweetvim&#39;]  こんな感じ。</description>
    </item>
    
    <item>
      <title>vimperator ツリー型タブとvimperatorの表示の上下を修正</title>
      <link>http://yukimemi.github.io/post/2014-01-05-vimperator_treestyletab/</link>
      <pubDate>Sun, 05 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2014-01-05-vimperator_treestyletab/</guid>
      <description>vimperator と ツリー型タブ は便利で使ってたのだが、 先日、表示がおかしくなってることに気づいた。
こんな感じ。
コマンドラインの補完部分に、タブ表示が覆い被さっている。
修正するには、 .vimperatorrc に、以下を記載したら出来た。
style! -name=treestyletab chrome://* .tabbrowser-tab { z-index: 0 !important; }  style コマンドで、既存のcssを書き換えることが出来るみたい。 詳細は、 :h style 。
修正後はこんな感じ。
ツリー型タブのcssのクラス名とかを調べるには、 DOM Inspector :: Add-ons for Firefox を使用した。
使い方は、 Dom Inspectorでブックマークサイドバーを開くコマンドを見つける がすごい参考になった。</description>
    </item>
    
    <item>
      <title>pyenv python でも rbenv</title>
      <link>http://yukimemi.github.io/post/2013-11-03-pyenv/</link>
      <pubDate>Sun, 03 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2013-11-03-pyenv/</guid>
      <description>一昔前は、python で仮想環境といえば、 virtualenv と virtualenvwrapper だったっぽいけど、 今は rbenv とほぼ同じ使い勝手の pyenv がおすすめっぽい。
名前も 「〜env」で一緒だしね。
簡単導入 以下を .zshenv に追記
# pyenv [ ! -d $HOME/.pyenv ] &amp;amp;&amp;amp; git clone git://github.com/yyuu/pyenv.git ~/.pyenv if [ -d $HOME/.pyenv ]; then [ ! -d $HOME/.pyenv/plugins/pyenv-virtualenv ] &amp;amp;&amp;amp; git clone git://github.com/yyuu/pyenv-virtualenv.git ~/.pyenv/plugins/pyenv-virtualenv export PYENV_ROOT=&amp;quot;$HOME/.pyenv&amp;quot; export PATH=$PYENV_ROOT/bin:$PATH eval &amp;quot;$(pyenv init -)&amp;quot; fi  zshを再起動すればインストール完了。 pyenv 使いたくないってなったら、1行目の git clone をコメントアウト。
pyenv 使用方法 1. python のインストール $ pyenv install -l Available versions: 2.</description>
    </item>
    
    <item>
      <title>Mac OS X Mavericks クリーンインストール</title>
      <link>http://yukimemi.github.io/post/2013-10-26-setup_mavericks/</link>
      <pubDate>Sat, 26 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2013-10-26-setup_mavericks/</guid>
      <description>Mavericks がなんと無料で出たので、早速アップデートしました。
新しいOSにする時は毎回全消去してからまっさらな状態で 新規インストールするので、今回も 【Mac】OS X Mavericks (マーベリックス)を クリーンインストールする方法 | 和洋風KAI を参考にして新規インストールした。
インストールした後は、以下のステップで環境を構築。
1. github と bitbucket にsshキーを登録 $ ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/Users/yukimemi/.ssh/id_rsa): [Enter] ... 全部 [Enter] .. . $ cat ~/.ssh/id_rsa.pub | pbcopy  github と bitbucket に元々登録してあったsshキーを削除して から、新たにクリップボードに入ってるキーを登録。
(このsshキーの登録もコマンドから出来たりせんのかな・・・)
2. github から、 dotfiles をクローン 自分の環境構築用 dotfiles をクローンする。
$ git clone git@github.com:yukimemi/dotfiles.git $ cd dotfiles $ ./setup.sh  これで一応ほぼ環境構築は終わり。 後は各アプリケーションの設定を個別にやるくらい。</description>
    </item>
    
    <item>
      <title>powershell ForEach-Objectでcontinue</title>
      <link>http://yukimemi.github.io/post/2013-10-19-foreach_object_continue/</link>
      <pubDate>Sat, 19 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2013-10-19-foreach_object_continue/</guid>
      <description>powershell の ForEach-Object で、continue しようと したら、思ったように動かなかった話。
こんなコードを書いた。
gci -r | % { if ($_.Name -match &amp;quot;^tes.*&amp;quot;) { continue } $_ }  現在のディレクトリ配下を再帰的に見て、ファイル名が tes から始まるもの以外を 表示する・・・みたいな処理。 マッチした場合のみ、 continue して次の処理に行きたいのだが、この書き方だと、 break したのと同じような動きになってしまい、初回マッチしたら、それ以降の処理 はされない。
やりたいことを満たすには、以下のように書けばいいみたい。
gci -r | % { if ($_.Name -match &amp;quot;^tes.*&amp;quot;) { return } $_ }  continue の代わりに return を使う。
参考: powershell - Why does continue behave like break in a Foreach-Object? - Stack Overflow</description>
    </item>
    
    <item>
      <title>powershell MacからWindowsへsshしてpowershell</title>
      <link>http://yukimemi.github.io/post/2013-10-13-powershell_server/</link>
      <pubDate>Sun, 13 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2013-10-13-powershell_server/</guid>
      <description>普段家で触れるのはMacだけど、仕事で使うのはWindows。 Windows でCUI環境といえば、今はもうコマンドプロンプトでは なくて powershell らしい。 そこで、 powershell を覚えようと思った。
僕はかたちから入るタイプなので、まずは環境構築から。
理想としては、 powershell のスクリプトを書いたり実行する のは普段使っているMacから行いたい。 そこで、MacからWindowsへsshして、Macのターミナルから powershell を実行することにする。 調べたら、 powershell server という便利なものがあるらしい。
PowerShell Server | Secure Remote Access to PowerShell Over SSH
上記からダウンロードして、インストール。 特に何も設定は変えずにそのままインストールした。 あとは、「other」タブにある、エンコーディングを「UTF-8」に設定して、「Start」。 Macからsshで簡単に接続できた。 これで powershell の勉強をやっていこう。</description>
    </item>
    
    <item>
      <title>powershell vim plugin</title>
      <link>http://yukimemi.github.io/post/2013-10-13-powershell_vim_plugin/</link>
      <pubDate>Sun, 13 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2013-10-13-powershell_vim_plugin/</guid>
      <description>powershell script を vim で書くためのプラグイン
NeoBundleLazy &#39;PProvost/vim-ps1&#39;, { \ &#39;autoload&#39; : {&#39;filetypes&#39;: [&#39;ps1&#39;]} \ }  </description>
    </item>
    
    <item>
      <title>vim-automatic &lt;C-[&gt;&lt;C-[&gt; でウィンドウクローズ</title>
      <link>http://yukimemi.github.io/post/2013-09-15-automatic_vim/</link>
      <pubDate>Sun, 15 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2013-09-15-automatic_vim/</guid>
      <description>automatic.vim という便利なプラギンがある。
これを利用すると、 Unite や QuickFix や help など、様々なウィンドウを一元管理出来るっぽい。
そこで、いろんなサイトを参考にやってみた。
&amp;quot; ESC2回押しで検索ハイライトを消去 autocm MyAutoCmd VimEnter,WinEnter,WinLeave * nmap &amp;lt;silent&amp;gt; &amp;lt;ESC&amp;gt;&amp;lt;ESC&amp;gt; :&amp;lt;C-u&amp;gt;nohlsearch&amp;lt;CR&amp;gt;&amp;lt;Plug&amp;gt;(anzu-clear-search-status) &amp;quot; vim-automatic {{{ function! s:my_temporary_window_init(config, context) silent! nunmap &amp;lt;ESC&amp;gt;&amp;lt;ESC&amp;gt; nmap &amp;lt;buffer&amp;gt; &amp;lt;C-[&amp;gt; :&amp;lt;C-u&amp;gt;q&amp;lt;CR&amp;gt; nmap &amp;lt;buffer&amp;gt; &amp;lt;ESC&amp;gt; :&amp;lt;C-u&amp;gt;q&amp;lt;CR&amp;gt; endfunction let g:automatic_default_match_config = { \ &#39;is_open_other_window&#39;: 1 \ } let g:automatic_default_set_config = { \ &#39;height&#39;: &#39;60%&#39;, \ &#39;move&#39;: &#39;bottom&#39;, \ &#39;apply&#39;: function(&#39;s:my_temporary_window_init&#39;) \ } let g:automatic_config = [ \ {&#39;match&#39;: {&#39;buftype&#39;: &#39;help&#39;}}, \ {&#39;match&#39;: {&#39;bufname&#39;: &#39;^.</description>
    </item>
    
    <item>
      <title>Ricty Mac HomebrewでRicty Powerline フォントをインストールする</title>
      <link>http://yukimemi.github.io/post/2013-09-14-ricty_powerline_install/</link>
      <pubDate>Sat, 14 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2013-09-14-ricty_powerline_install/</guid>
      <description>最近動作が重くなってきたこともあり、Mountain Lion を 再インストールした。
再インストールは簡単で、起動時に 「 Command + R 」を押せばOK。
まずディスクユーティリティでディスクを消去して、Mountain Lion の再インストール。
再インストール後、 iTerm2 や、 MacVim のフォント Ricty のインストールと Powerline のパッチ当てをまた簡単に出来るようにスクリプトとしてまとめた。
#!/bin/sh brew tap sanemat/font brew install ricty cmd=$(brew info ricty | grep &amp;quot;Ricty\*.ttf&amp;quot; | sed -e &amp;quot;s/.*\(cp -f.*\)/\1/&amp;quot;) echo $cmd eval $cmd #git clone https://github.com/Lokaltog/powerline.git ~/.powerline #fontforge -script $HOME/.powerline/font/fontpatcher.py ~/Library/Fonts/Ricty-Regular.ttf git clone https://github.com/Lokaltog/vim-powerline ~/.vim-powerline fontforge -lang=py -script ~/.vim-powerline/fontpatcher/fontpatcher ~/Library/Fonts/Ricty-Regular.ttf mv -f *.ttf ~/Library/Fonts/ # wait a minute fc-cache -vf  Powerline の方のパッチではなぜかうまく出来なかったので、 vim-powerline の方で行っている。</description>
    </item>
    
    <item>
      <title>Vim coffeescript syntastic</title>
      <link>http://yukimemi.github.io/post/2013-08-11-syntastic_coffeelint/</link>
      <pubDate>Sun, 11 Aug 2013 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2013-08-11-syntastic_coffeelint/</guid>
      <description>vim で保存時に自動で構文チェックとかを行なってくれるプラギンに Syntastic というものがある。
coffeescript を書く時も、これを使うと便利。
インストールは NeoBundle で一発。
NeoBundle &#39;scrooloose/syntastic.git&#39;, { \ &#39;build&#39;: { \ &#39;mac&#39;: [&#39;pip install pyflake&#39;, &#39;npm -g install coffeelint&#39;], \ &#39;unix&#39;: [&#39;pip install pyflake&#39;, &#39;npm -g install coffeelint&#39;] \ }}  上記のように書いておけば、 Syntastic をインストールする時に自動で、 pyflake と coffeelint をインストールしてくれる。 NeoBundle すごい。
後は普通にコードを書いて、保存すると、自動でエラー行にチェックがつく。 エラーの内容を見たい時は、
:Errors  コマンドでおｋ
coffeelint はデフォルトでインデントは 2 みたい。
.vimrc に以下のように書いておいた。
autocmd MyAutoCmd BufNewFile,BufRead .coffee setl ft=coffee fenc=utf8 ff=unix tabstop=4 shiftwidth=2 softtabstop=2 expandtab  また、1行の長さが 80文字 を超えてもエラーになるのが邪魔だったので、これは無視したい。</description>
    </item>
    
    <item>
      <title>cygwin インストールコマンド</title>
      <link>http://yukimemi.github.io/post/2013-07-27-cygwin_setup/</link>
      <pubDate>Sat, 27 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2013-07-27-cygwin_setup/</guid>
      <description>Windows では泣く泣く cygwin を使用する。
cygwin のインストールは setup.exe というインストーラーがあり、 必要なパッケージは手動でダウンロードしなきゃいけない。
なんとか簡単にインストール出来ないかと探っていたところ、 cygwin のコマンドラインオプションがあることを発見。
以下のバッチスクリプトを作っておくと簡単にインストールできる。
setup-x86.exe -q -d -D -L -s http://ftp.jaist.ac.jp/pub/cygwin/ -l &amp;quot;%USERPROFILE%\.cygwin&amp;quot; -R c:\cygwin -P gcc,git,git-completion,git-svn,make,vim,wget,ruby,screen,zsh,subversion  それぞれのオプションの意味は以下の通り
Command Line Options: -A --disable-buggy-antivirus Disable known or suspected buggy antivirus software packages during execution. -C --categories Specify entire categories to install -D --download Download from internet -d --no-desktop Disable creation of desktop shortcut -h --help print help -K --pubkey URL of extra public key file (gpg format) -L --local-install Install from local directory -l --local-package-dir Local package directory -n --no-shortcuts Disable creation of desktop and start menu shortcuts -N --no-startmenu Disable creation of start menu shortcut -O --only-site Ignore all sites except for -s -P --packages Specify packages to install -p --proxy HTTP/FTP proxy (host:port) -q --quiet-mode Unattended setup mode -r --no-replaceonreboot Disable replacing in-use files on next reboot.</description>
    </item>
    
    <item>
      <title>qfixhowm Vim でメモ</title>
      <link>http://yukimemi.github.io/post/2013-06-29-qfixhowm/</link>
      <pubDate>Sat, 29 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2013-06-29-qfixhowm/</guid>
      <description>vimでメモをとる場合、簡単な設定では vimrc に JunkFile コマンドを定義するなどする。
&amp;quot; JunkFile {{{ &amp;quot; http://vim-users.jp/2010/11/hack181/ &amp;quot;&amp;quot; Open junk file. command! -nargs=0 JunkFile call s:open_junk_file() function! s:open_junk_file() let l:junk_dir = $HOME . &#39;/.vim_junk&#39;. strftime(&#39;/%Y/%m&#39;) if !isdirectory(l:junk_dir) call mkdir(l:junk_dir, &#39;p&#39;) endif let l:filename = input(&#39;Junk Code: &#39;, l:junk_dir.strftime(&#39;/%Y-%m-%d-%H%M%S.&#39;)) if l:filename != &#39;&#39; execute &#39;edit &#39; . l:filename endif endfunction &amp;quot; }}}  これは実行時に拡張子が自由に設定出来るので、簡単にスクリプトを試してみたい場合 はとても便利。
でも、やっぱり最近、メモは統合的に管理したいと思い、 QfixHowm を導入することにした。
インストール Neobundle で一発
NeoBundle &#39;fuenor/qfixgrep&#39; NeoBundle &#39;fuenor/qfixhowm&#39;  qfixgrep もいれとくと何かといいみたい。</description>
    </item>
    
    <item>
      <title>Tinkerer で「続きを読む」</title>
      <link>http://yukimemi.github.io/post/2013-06-23-add_more_directive/</link>
      <pubDate>Sun, 23 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2013-06-23-add_more_directive/</guid>
      <description>Tinkererで「続きを読む」をいれる方法。
「続きを読む」を入れたいところに more ディレクティブを入れる。
.. more::  以上！
参考: Tinkering — Tinkerer</description>
    </item>
    
    <item>
      <title>Mac OSX Mountain Lion MongoDB セットアップ</title>
      <link>http://yukimemi.github.io/post/2013-06-16-setup_mongodb/</link>
      <pubDate>Sun, 16 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2013-06-16-setup_mongodb/</guid>
      <description>mongodb をいれてみた。
$ brew install mongodb  これでインストール完了。簡単。
自動起動する設定も書いてあるからそれを実行するだけ。
$ ln -sfv /usr/local/opt/mongodb/*.plist ~/Library/LaunchAgents $ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mongodb.plist  これで自動起動される。
手動で起動するには、次のようにする。
$ launchctl start homebrew.mxcl.mongodb  </description>
    </item>
    
    <item>
      <title>tmuxで画面サイズをリセットしてアタッチ</title>
      <link>http://yukimemi.github.io/post/2013-06-16-tmux_detach_before_attach/</link>
      <pubDate>Sun, 16 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2013-06-16-tmux_detach_before_attach/</guid>
      <description>tmux で attach する場合、事前に attach されていた 画面がある時、その画面サイズに固定されてしまう。
そのため、 attach する前にオプションで detach させるようにする。
zsh で自動 attach するには、 .zshrc にこんな感じで書いてる。
if [ -z $TMUX ]; then tmux attach -d || tmux fi  参考: tmuxでアタッチした時、画面がおかしくなるのを直した #tmux - Qiita [キータ]
Tmuxの設定とメモ</description>
    </item>
    
    <item>
      <title>Tinkerer にソーシャルボタン追加</title>
      <link>http://yukimemi.github.io/post/2013-06-15-add_social_button/</link>
      <pubDate>Sat, 15 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2013-06-15-add_social_button/</guid>
      <description>今時のブログとしては、ソーシャルボタンは追加したい。
参考になる記事がいっぱいあったので、参考にしてやってみた。
事前準備 layout.html というファイルと page.html というファイルを作る。
layout.html は全体？ page.html は記事一つ一つみたいな感じがする。たぶん。
$ vim _templates/layout.html  中身はこんな感じ。
{% extends &amp;quot;!layout.html&amp;quot; %} {% block extrahead %} &amp;lt;!-- ここに html の ヘッダ部分に追加するスクリプトを書く --&amp;gt; {% endblock %}  ね。簡単でしょ。 1行目で既存の layout.html を継承してる。たぶん
layout.html では、extrahead というブロックを使うことで、既存の &amp;lt;head&amp;gt;タグに追加の情報を出力することが出来る。
次に page.html
$ vim _templates/page.html  中身はこんな感じ。
{% extends &amp;quot;!page.html&amp;quot; %} {% block body %} {{ timestamp(metadata.formatted_date) }} {% block buttons %} &amp;lt;!-- ここに ソーシャルボタンのコードを追加していく --&amp;gt; {% endblock %} {{ body }} {{ self.</description>
    </item>
    
    <item>
      <title>Tinkererでテーマカスタマイズ</title>
      <link>http://yukimemi.github.io/post/2013-06-13-change_theme/</link>
      <pubDate>Thu, 13 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2013-06-13-change_theme/</guid>
      <description>Tinkererのテーマをカスタマイズしたいと思った。
カスタマイズといってもそんな大層なことがしたいわけではなく。
デフォルトの &amp;ldquo;modern5&amp;rdquo; だと、横幅が狭いと思ったので広くしたかっただけ。 今時のワイド画面が多い中ではもうちょっと広くてもいいでしょう。
カスタマイズの方法は、まず元になるテーマである &amp;ldquo;modern5&amp;rdquo; をコピーしてくる。
$ mkdir -p _themes/mytheme $ cp -r ~/.virtualenvs/2.7.4/lib/python2.7/site-packages/tinkerer/themes/modern5/_themes/mytheme  それから、conf.pyにmythemeを使うことを明記する。
# Pick another Tinkerer theme or use your own html_theme = &amp;quot;mytheme&amp;quot; # Add other theme paths here html_theme_path = [&#39;_themes&#39;, tinkerer.paths.themes]  後は _themes/mytheme/static/modern5.css_t を編集すればいいみたい。
よくわからないけど、 width がついているところを全部 +200px したった。
参考: Tinkererを使ってblogを始める - KRAKENBEAL RECORDS</description>
    </item>
    
    <item>
      <title>First Tinkerer</title>
      <link>http://yukimemi.github.io/post/2013-05-27-first_tinkerer/</link>
      <pubDate>Mon, 27 May 2013 00:00:00 +0000</pubDate>
      
      <guid>http://yukimemi.github.io/post/2013-05-27-first_tinkerer/</guid>
      <description>Tinkerer でブログ書く。
今まではgithubでocropressで書いてたけど、やっぱこれからは sphinx でしょ！ markdown より reStructuredText でしょ！
で、 bitbucket を使う。
bitbucket では、 github と同じように、 &amp;lt;ユーザー名&amp;gt;.bitbucket.org で 自分のページを持つことが出来る。
リポジトリの作成 bitbucket で、 &amp;lt;ユーザー名&amp;gt;.bitbucket.org というリポジトリを作る。 僕の場合は、 yukimemi.bitbucket.org
Tinkererのインストール 僕の場合は python3 ではダメだったので、 python2.7.4 で virtualenv を作成して Tinkerer をインストールした。 python のインストールには pythonz を使用している。
$ pythonz install 2.7.4 $ mkvirtualenv -p /Users/yukimemi/.pythonz/pythons/CPython-2.7.4/bin/python --distribute 2.7.4 $ workon 2.7.4 $ easy_install pip $ pip install Tinkerer  ブログの作成 bitbucketでgit repositoryを作成したら、それを clone する。
$ git clone ssh://git@bitbucket.</description>
    </item>
    
  </channel>
</rss>